<style type="text/css">

	#battle {
		display: flex;
		justify-content: center;
	}

	#battle_div_cvs {
		display: flex;
		justify-content: center;
	}

	#battle_cvs {
		border: 2px solid #000;
	}

	#battle_div_tips {
		display: flex;
		justify-content: center;
	} 

	#battle_tips {
		font-size:22px;
	}

	#battle_div_return {
		display: flex;
		justify-content: center;
	}

	#battle_return {
		width: 130px;
		height: 60px;
	}
</style>

<div id="battle">welcome battle!</div>
<div id="battle_div_cvs"><canvas id="battle_cvs"></canvas></div>
<div id="battle_div_tips"><p id="battle_tips"></p></div>
<div id="battle_div_return"><button id="battle_return">返回</button></div>

<script>
	(function() {
		
		var GRID_SIZE = 40;
		var HORIZONTAL_SIZE = 15;
		var VERTICAL_SIZE = 12;
		var checkerboard = [];
		var whiteTrun = true;

		var cvs = document.getElementById('battle_cvs');
		var ctx = cvs.getContext('2d');

		cvs.width = GRID_SIZE * HORIZONTAL_SIZE;
		cvs.height = GRID_SIZE * VERTICAL_SIZE;


		function play_one(chess, x, y) {
			var data = {
				chess: chess, // 1白棋 2黑棋
				x: x, // 当前下的x坐标
				y: y  // 当前下的y坐标
			};
			socket.emit('play_one', data);
		}

		function init() {
			socket.emit('player_chess');
			for(var i = -5; i < HORIZONTAL_SIZE + 5; i++) {
				checkerboard[i] = [];
				for (var j = -5; j < VERTICAL_SIZE + 5; j++)
				{
					checkerboard[i][j] = {
						state: 0,
						type: true
					};
				}
			}
			drawCheckerboard();
			cvs.onclick = putChess;
		}

		/*画棋盘*/
		function drawCheckerboard() {
			for (var i = 0; i < HORIZONTAL_SIZE; i++)
			{
				for (var j = 0; j < VERTICAL_SIZE; j++)
				{
					ctx.beginPath();
					//边框颜色
					ctx.strokeStyle = '#000';
					ctx.fillStyle = 'yellow';
					ctx.fillRect(i*GRID_SIZE, j*GRID_SIZE, GRID_SIZE, GRID_SIZE);
					ctx.strokeRect(i*GRID_SIZE, j*GRID_SIZE, GRID_SIZE, GRID_SIZE);
					ctx.closePath();
				}
			}
		}

		/**
		* 画棋子
		* @param {*} x
		* @param {*} y
		*/

		function drawArc(x, y, chess) {
			ctx.beginPath();
			ctx.arc(x*GRID_SIZE + GRID_SIZE/2, y*GRID_SIZE + GRID_SIZE/2, (GRID_SIZE/ 2) * 0.8, 0, 2*Math.PI);
			ctx.fillStyle = (chess == 2?  '#000': '#eee');
			ctx.fill();
			ctx.closePath();

			checkerboard[x][y].state = 1;
			checkerboard[x][y].type = whiteTrun;
		}


		/**
		* 放置棋子
		* @param {*} e
		*/
		function putChess(e) {
			//当前鼠标点击位置
			var x = e.pageX - cvs.offsetLeft;
			var y = e.pageY - cvs.offsetTop;

			//落在哪个格子
			x = parseInt(x/GRID_SIZE);
			y = parseInt(y/GRID_SIZE);

			//有棋子
			if(checkerboard[x][y].state) 
				return;

			play_one(whiteTrun == true ? 1 : 2, x, y);

		}

		document.getElementById('battle_return').onclick = function() {
			document.getElementById('battle_tips').innerText = 'wwww';
			init();
		}

		socket.on('player_chess', function(chess){
			whiteTrun = chess == 1? true: false;
			console.log('chess ' + chess);
		});


		socket.on('play_state', function(data){
			var chess = data.chess; // 1白棋 2黑棋
			var play_state = data.state; // -1下棋失败 6胜利 9继续下
			console.log(play_state);

			var x = data.x;
			var y = data.y;
			

			if (play_state == 9)
			{
				drawArc(x, y, chess);
				document.getElementById('battle_tips').innerText = (chess == 2 ? '现在轮到白棋落子': '现在轮到黑棋落子');
			}
			else if (play_state == 6)
			{
				drawArc(x, y, chess);
				document.getElementById('battle_tips').innerText = (chess == 2 ? '白棋胜': '黑棋胜');
			}
		});

		init();
		
	})();

</script>